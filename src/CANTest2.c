/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  CANTest2                               */
/*      FILE         :  CANTest2.c                             */
/*      DESCRIPTION  :  Main Program                           */
/*                                                             */
/*      This file was generated by e2 studio.                  */
/*                                                             */
/***************************************************************/

#include <iodefine.h>

#define TIMEOUT_COUNTER_DEFAULT 0x20000

#define RESULT_OK 0
#define RESULT_ERROR 1
#define RESULT_TIMEOUT 2
#define RESULT_INVALID -1

#define CAN_MODE_OPERATE 0
#define CAN_MODE_RESET 1
#define CAN_MODE_HALT 2
#define CAN_MODE_FORCE_RESET 3

#define CAN_FRAME_DATA 0
#define CAN_FRAME_REMOTE 1

#ifdef CPPAPP
//Initialize global constructors
extern void __main()
{
  static int initialized;
  if (! initialized)
    {
      typedef void (*pfunc) ();
      extern pfunc __ctors[];
      extern pfunc __ctors_end[];
      pfunc *p;

      initialized = 1;
      for (p = __ctors_end; p > __ctors; )
    (*--p) ();

    }
}
#endif 

typedef struct {
	int id;
	int dlc;
	char data[8];
} can_frame_t;

int can0_switch_mode(int mode_code) {
	int timeout_counter = TIMEOUT_COUNTER_DEFAULT;

	switch (mode_code) {
	case CAN_MODE_OPERATE:
		MSTP(CAN0) = 0;
		while (MSTP(CAN0) && (--timeout_counter != 0))
			;
		if (timeout_counter == 0)
			return RESULT_TIMEOUT;

		timeout_counter = TIMEOUT_COUNTER_DEFAULT;
		CAN0.CTLR.BIT.CANM = mode_code;
		while ((CAN0.STR.BIT.RSTST || CAN0.STR.BIT.HLTST) && (--timeout_counter != 0))
			;
		if (timeout_counter == 0)
			return RESULT_TIMEOUT;

		return RESULT_OK;

	case CAN_MODE_HALT:
		CAN0.CTLR.BIT.CANM = mode_code;
		while ((!CAN0.STR.BIT.HLTST) && (--timeout_counter != 0))
			;
		if (timeout_counter == 0)
			return RESULT_TIMEOUT;

		return RESULT_OK;

	case CAN_MODE_RESET:
		CAN0.CTLR.BIT.CANM = mode_code;
		while ((!CAN0.STR.BIT.RSTST) && (--timeout_counter != 0))
			;
		if (timeout_counter == 0)
			return RESULT_TIMEOUT;

		return RESULT_OK;

	default:
		return RESULT_INVALID;
	}
}

int can0_wakeup(void) {
	int timeout_counter = TIMEOUT_COUNTER_DEFAULT;

	CAN0.CTLR.BIT.SLPM = 0;
	while ((CAN0.STR.BIT.SLPST) && (--timeout_counter != 0))
		;
	if (timeout_counter == 0)
		return RESULT_TIMEOUT;

	return RESULT_OK;
}

int can0_sleep(void) {
	int timeout_counter = TIMEOUT_COUNTER_DEFAULT;

	int halt_result = can0_switch_mode(CAN_MODE_HALT);
	if (halt_result != RESULT_OK)
		return halt_result;

	CAN0.CTLR.BIT.SLPM = 1;
	while ((!CAN0.STR.BIT.SLPST) && (--timeout_counter != 0))
		;
	if (timeout_counter == 0)
		return RESULT_TIMEOUT;

	return RESULT_OK;
}

int can0_set_bitrate(int bitrate_kbps, int prescaler, int pclk_mhz) {
	// 500 4 50
	if (bitrate_kbps < 0 || 1000 < bitrate_kbps)
		return RESULT_INVALID;

	if (prescaler < 1 || 1024 < prescaler)
		return RESULT_INVALID;

	if (pclk_mhz < 0 || 50 < pclk_mhz)
		return RESULT_INVALID;

	int fcanclk = pclk_mhz * 1000000 / prescaler;
	int tq_total = fcanclk / (bitrate_kbps * 1000);

	if (tq_total < 8 || 25 < tq_total)
		return RESULT_ERROR;

	/*
	 *  <--------bit time-------->
	 *  |SS|    TSEG1    | TSEG2 |
	 *  +--+-------------+-------+-------+->t
	 *  0 1Tq            |    tq_total  25Tq
	 *          (tq_total - SS) * 2/3
	 *
	 *  e.g)
	 *  	tq_total = 25
	 *  	SS    = 1 Tq
	 *  	TSEG1 = 16 Tq
	 *  	TSEG2 = 8 Tq
	 *
	 *  	tq_total = 24
	 *  	SS    = 1 Tq
	 *  	TSEG1 = 15 Tq
	 *  	TSEG2 = 8 Tq
	 *
	 *  	tq_total = 8
	 *  	SS    = 1 Tq
	 *  	TSEG1 = 4 Tq
	 *  	TSEG2 = 3 Tq
	 */
	const int ss_tq = 1;
	int tseg1_tq = (tq_total - ss_tq) * 2 / 3;
	int tseg2_tq = tq_total - ss_tq - tseg1_tq;

	CAN0.BCR.BIT.SJW = 0; // 最同期ジャンプ幅; 「再同期ジャンプ幅は通常１とすれば十分です」（MCP2515データシート）
	CAN0.BCR.BIT.BRP = prescaler - 1;
	CAN0.BCR.BIT.TSEG1 = tseg1_tq - 1;
	CAN0.BCR.BIT.TSEG2 = tseg2_tq - 1;

	return RESULT_OK;
}

int can0_load_mailbox(int mb_number, can_frame_t frame, int frame_type, int oneshot) {
	int i = 0;

	if (mb_number < 0 || 31 < mb_number)
		return RESULT_INVALID;
	if (frame.id < 0 || 0x1FFFFFFF < frame.id)
		return RESULT_INVALID;
	if (frame.dlc < 0 || 8 < frame.dlc)
		return RESULT_INVALID;
	if (frame_type != CAN_FRAME_DATA && frame_type != CAN_FRAME_REMOTE)
		return RESULT_INVALID;

	do {
		CAN0.MCTL[mb_number].BYTE = 0x00;
	} while (CAN0.MCTL[mb_number].BYTE != 0x00);

	CAN0.MIER = 1 << mb_number;

	CAN0.MB[mb_number].ID.BIT.SID = frame.id;
	CAN0.MB[mb_number].ID.BIT.RTR = frame_type == CAN_FRAME_REMOTE;
	CAN0.MB[mb_number].ID.BIT.IDE = 0/*0x7FF < frame.id*/;
	CAN0.MB[mb_number].TS.WORD = 0x0000;
	CAN0.MB[mb_number].DLC.BIT.DLC = frame.dlc;
	for (i = 0; i < 8; i++)
		CAN0.MB[mb_number].DATA[i] = frame.data[i];

	CAN0.MCTL[mb_number].BIT.TX.ONESHOT = oneshot;

	return RESULT_OK;
}

int can0_transmit_mailbox(int mb_number) {
	if (mb_number < 0 || 31 < mb_number)
		return RESULT_INVALID;

	CAN0.MCTL[mb_number].BIT.TX.RECREQ = 0;
	CAN0.MCTL[mb_number].BIT.TX.TRMREQ = 1;

	return RESULT_OK;
}

int main(void) {
	int switch_result = RESULT_OK;
	int i = 0;
	char deadbeaf[8] = { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7 };
	can_frame_t deadbeaf_frame;
	deadbeaf_frame.id = 0x70F;
	deadbeaf_frame.dlc = 8;
	for (i = 0; i < 8; i++)
	    deadbeaf_frame.data[i] = deadbeaf[i];
//	can_frame_t deadbeaf_frame = { 0x48, 2, deadbeaf };

	PORTA.DDR.BIT.B2 = 1;
	PORTA.DDR.BIT.B3 = 1;
	PORTA.DR.BIT.B2 = 1;
	PORTA.DR.BIT.B3 = 1;

	/**************************************
	 * Post-hardware-reset configurations *
	 **************************************/

	IOPORT.PFJCAN.BIT.CANE = 1; // Enable CTX-A, CRX-A
	IOPORT.PFJCAN.BIT.CANS = 0; // PB5 = CTX-A; PB6 = CRX-A
	PORTB.DR.BIT.B5 = 1;        // PB5(CTX-A) = H
	PORTB.ICR.BIT.B6 = 1;       // ICR config for PB6(CRX-A)

	MSTP(CAN0) = 0;

	can0_wakeup();

	PORTA.DR.BIT.B2 = can0_switch_mode(CAN_MODE_RESET);

	CAN0.CTLR.BIT.MBM = 0;
	CAN0.CTLR.BIT.IDFM = 0;
	CAN0.CTLR.BIT.MLM = 0;
	CAN0.CTLR.BIT.TPM = 0;
	CAN0.CTLR.BIT.TSRC = 0;
	CAN0.CTLR.BIT.TSPS = 3;
	CAN0.CTLR.BIT.BOM = 0;
	CAN0.CTLR.BIT.RBOC = 0;

	PORTA.DR.BIT.B3 = can0_set_bitrate(500, 4, 25);

	CAN0.MIER = 0x00000000; // Prohibit all mailbox interrupts
	CAN0.EIER.BYTE = 0x00;  // Prohibit all error interrupts

	for (i = 0; i < 32; i++) {
		CAN0.MKR[i].LONG = 0x00000000; // Will not be compared with any bits
		CAN0.MKIVLR = 0x00000000;      // Enable all masks for each mailbox
	}

	can0_switch_mode(CAN_MODE_OPERATE);

	can0_load_mailbox(0, deadbeaf_frame, CAN_FRAME_DATA, 0);
	can0_transmit_mailbox(0);

    while(1) {
    }

    return 0;
}
